module;

#include <cstdint>
#include <cstddef>

export module rbx.object;

import memory;
import rbx.constants;

auto number_xor = *reinterpret_cast<std::uint64_t*>(mem::rebase(0x2aa67b0, 0x400000));

export namespace rbx {
	struct State;
	union UpVal;
	union Closure;
	struct TValue;
	union GCObject;

	using CFunction = int(*)(rbx::State*);

	struct closed {
		rbx::UpVal* next;
		rbx::UpVal* prev;
		rbx::TValue* value;
	};

	struct TValue {
		union {
			rbx::GCObject* gc;
			void* p;
			std::uint64_t n_xor;
			bool b;
		} value;
		std::uintptr_t _;
		int tt;
	};

	union UpVal {
		rbx::TValue value;
		rbx::closed* l;
	};

	struct Table {
		std::uint8_t _[7];
		std::uint8_t readonly;
	};
	
	struct LClosure {
		std::uint8_t _[7]; // 0
		std::uint8_t isC; // [7] + 1
		std::uint8_t nups; // [8] + 1
		std::uint8_t maxstacksize; // [9] + 1
		std::uint8_t __[6]; // [10] + 6
		rbx::Table* env;
		std::uint8_t ___[4];
		std::uintptr_t p;
		std::uint8_t ____[4];
		rbx::UpVal upvals;
	};

	struct CClosure {
		std::uint8_t _[7]; // [0]
		std::uint8_t isC; // [7] + 1
		std::uint8_t nups; // [8] + 1
		std::uint8_t __[7]; // [9] + 7
		rbx::Table* env; // [16] + 4
		std::uint8_t ___[4]; // [20] + 4
		std::uintptr_t f; // [24] + 4
		//std::uintptr_t extra_space;
		rbx::CFunction extra_space; // [28] + 4 (this is supposed to be a pointer, but i interpret it as a cfunction since i use it to store the function i put into pushcclosure)
		std::uint8_t ____[8]; // [32 + 8]
		rbx::TValue upvals; // [40] + 12
	};

	union Closure {
		LClosure l;
		CClosure c;
	};

	struct GCheader {
		rbx::GCObject* next;
		//std::uint8_t _[2];
		std::uint8_t tt;
	};

	union GCObject {
		rbx::GCheader gch;
		std::uintptr_t s;
		rbx::Table* h;
		rbx::Closure* cl;
	};

	struct ExtraSpace {
		std::uint8_t _[24];
		std::uintptr_t identity;
		std::uint8_t __[24];
		std::uintptr_t script_ptr;
	};

	struct State {
		std::uint8_t _[24];
		rbx::TValue* base;
		rbx::TValue* top;
		std::uint8_t __[68];
		std::uintptr_t namecall;
		std::uint8_t ___[8];
		rbx::ExtraSpace* extra_space;
	};

	auto hvalue = [](rbx::TValue* obj) {
		return obj->value.gc->h;
	};

	auto bvalue = [](rbx::TValue* obj) {
		return obj->value.b;
	};

	auto nvalue = [](rbx::TValue* obj) {
		double result;
		*reinterpret_cast<uint64_t*>(&result) = obj->value.n_xor ^ number_xor;
		return result;
	};

	auto thvalue = [](rbx::TValue* obj) {
		return reinterpret_cast<rbx::State*>(obj->value.gc);
	};

	auto svalue = [](rbx::TValue* obj) {
		return obj->value.gc->s;
	};

	auto clvalue = [](rbx::TValue* obj) {
		return obj->value.gc->cl;
	};

	auto setnvalue = [](rbx::TValue* obj, double val) {
		obj->value.n_xor = number_xor ^ *reinterpret_cast<std::uint64_t*>(&val);
		obj->tt = rbx::TNUMBER;
	};
	
	auto setbvalue = [](rbx::TValue* obj, bool b) {
		obj->value.b = b;
		obj->tt = rbx::TBOOLEAN;
	};

	auto setsvalue = [](rbx::TValue* obj, std::uintptr_t s) {
		obj->value.gc->s = s;
		obj->tt = rbx::TSTRING;
	};

	auto sethvalue = [](rbx::TValue* obj, rbx::Table* h) {
		obj->value.gc->h = h;
		obj->tt = rbx::TTABLE;
	};

	auto setpvalue = [](rbx::TValue* obj, void* p) {
		obj->value.p = p;
		obj->tt = rbx::TLIGHTUSERDATA;
	};

	auto setthvalue = [](rbx::TValue* obj, rbx::State* th) {
		obj->value.gc = reinterpret_cast<rbx::GCObject*>(th);
		obj->tt = rbx::TTABLE;
	};

	auto setclvalue = [](rbx::TValue* obj, rbx::Closure* cl) {
		obj->value.gc->cl = cl;
		obj->tt = rbx::TFUNCTION;
	};

	auto setobj = [](rbx::TValue* obj, rbx::TValue* obj2) {
		*obj = *obj2;
	};

	auto setnilvalue = [](rbx::TValue* obj) {
		obj->tt = rbx::TNIL;
	};

	auto rawstrvalue = [](rbx::TValue* obj) {
		return reinterpret_cast<const char*>(obj->value.gc->s + 20);
	};

	auto incr_top = [](rbx::State* R) {
		*reinterpret_cast<std::uintptr_t*>(reinterpret_cast<std::uintptr_t>(R) + offsetof(State, top)) += sizeof(rbx::TValue);
	};

	auto decr_top = [](rbx::State* R) {
		*reinterpret_cast<std::uintptr_t*>(reinterpret_cast<std::uintptr_t>(R) + offsetof(State, top)) -= sizeof(rbx::TValue);
	};
}
