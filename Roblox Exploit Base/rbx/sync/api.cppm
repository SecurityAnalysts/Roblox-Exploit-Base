module;

#include <iostream>
#include <string>
#include <array>
#include <bitset>

export module rbx.api;

import memory;

import rbx.object;
import rbx.constants;
import rbx.task_scheduler;
import rbx.bypass.retcheck;

auto get_lua_state_from_script_context = reinterpret_cast<rbx::State * (__thiscall*)(std::uintptr_t, int*)>(mem::rebase(0x7abca0, 0x400000));

auto _index2adr = reinterpret_cast<rbx::TValue* (__stdcall*)(rbx::State*, int)>(mem::rebase(0x15e5aa0, 0x400000));
auto _pushcclosure = reinterpret_cast<void(__stdcall*)(rbx::State*, std::uintptr_t, const char*, int, std::uintptr_t)>(rbx::bypass::retcheck(mem::rebase(0x15e68c0, 0x400000)));
auto _newuserdata = reinterpret_cast<void* (*)(rbx::State*, std::size_t, char)>(rbx::bypass::retcheck(mem::rebase(0x15e65c0, 0x400000)));
auto _sandbox = reinterpret_cast<int(*)(rbx::State * R, const std::bitset<16>&, int*)>(mem::rebase(0x7ba450, 0x400000));
auto number_xor = *reinterpret_cast<std::uint64_t*>(mem::rebase(0x2aa67b0, 0x400000));
auto _tointeger = reinterpret_cast<int(*)(rbx::State*, int, bool*)>(rbx::bypass::retcheck(mem::rebase(0x15e7ee0, 0x400000)));

export namespace rbx {
	auto get_task_scheduler = reinterpret_cast<rbx::task_scheduler * (*)()>(mem::rebase(0x10ca000, 0x400000));

	std::uintptr_t get_script_context() {
		return ([]() -> std::uintptr_t {
			for (const auto& job : *rbx::get_task_scheduler()) {
				if (job->name == "WaitingScriptJob") {
					return (*reinterpret_cast<rbx::task_scheduler::waiting_script_job*>(job.get())).script_context;
				}
			}

			return 0;
		})();
	}

	auto get_lua_state = []() -> rbx::State* {
		int flag = 0;
		return get_lua_state_from_script_context(get_script_context(), &flag);
	};

	auto getmetatable = reinterpret_cast<int(__fastcall*)(rbx::State*, int)>(rbx::bypass::retcheck(mem::rebase(0x15e60d0, 0x400000)));
	auto getfield = reinterpret_cast<void(*)(rbx::State*, int, const char*)>(rbx::bypass::retcheck(mem::rebase(0x15e6020, 0x400000)));
	auto gettable = reinterpret_cast<void(*)(rbx::State*, int)>(rbx::bypass::retcheck(mem::rebase(0x15e6190, 0x400000)));
	
	auto setmetatable = reinterpret_cast<int(*)(rbx::State*, int)>(rbx::bypass::retcheck(mem::rebase(0x15e7740, 0x400000)));
	auto setfield = reinterpret_cast<void(__stdcall*)(rbx::State*, int, const char*)>(rbx::bypass::retcheck(mem::rebase(0x15e7690, 0x400000)));
	auto settable = reinterpret_cast<void(*)(rbx::State*, int)>(rbx::bypass::retcheck(mem::rebase(0x15e7930, 0x400000)));

	auto newthread = reinterpret_cast<rbx::State* (*)(rbx::State* R)>(rbx::bypass::retcheck(mem::rebase(0x15e6530, 0x400000)));
	auto newlstr = reinterpret_cast<std::uintptr_t(__fastcall*)(rbx::State*, const char*, std::size_t)>(mem::rebase(0x15fe5b0, 0x400000));

	auto createtable = reinterpret_cast<void(*)(rbx::State*, int, int)>(rbx::bypass::retcheck(mem::rebase(0x15e5d90, 0x400000)));
	auto objlen = reinterpret_cast<int(*)(rbx::State* R, int)>(mem::rebase(0x15e66d0, 0x400000));
	auto rawgeti = reinterpret_cast<void(*)(rbx::State * R, int, int)>(rbx::bypass::retcheck(mem::rebase(0x15e7110, 0x400000)));
	auto rawseti = reinterpret_cast<void(*)(rbx::State * R, int, int)>(rbx::bypass::retcheck(mem::rebase(0x15e7260, 0x400000)));
	
	auto pcall = reinterpret_cast<int(*)(rbx::State*, int, int, int)>(rbx::bypass::retcheck(mem::rebase(0x15e67b0, 0x400000)));
	

	auto newtable = [](rbx::State* R) {
		rbx::createtable(R, 0, 0);
	};

	auto newuserdata = [](rbx::State* R, std::size_t size) {
		return _newuserdata(R, size, 0);
	};

	auto index2adr = [](rbx::State* R, int idx) {
		if (idx > 0) {
			return R->base + (idx - 1);
		}

		return _index2adr(R, idx);
	};

	auto type = [](rbx::State* R, int idx) {
		return index2adr(R, idx)->tt;
	};

	auto gettop = [](rbx::State* R) {
		return R->top - R->base;
	};

	auto settop = [](rbx::State* R, int idx) {
		if (idx >= 0) {
			while (R->top < R->base + idx) {
				setnilvalue(R->top++);
			}

			R->top = R->base + idx;
		}
		else {
			R->top += idx + 1;
		}
	};

	auto pop = [](rbx::State* R, int n) {
		rbx::settop(R, -1 - (n));
	};

	auto insert = [](rbx::State* R, int idx) {
		rbx::TValue* obj = rbx::index2adr(R, idx);

		for (TValue* obj2 = R->top; obj2 > obj; obj2--) {
			rbx::setobj(obj2, obj2 - 1);
		}
	};

	auto remove = [](rbx::State* R, int idx) {
		rbx::TValue* obj = rbx::index2adr(R, idx);

		while (++obj < R->top) {
			rbx::setobj(obj - 1, obj);
		}

		R->top--;
	};

	auto getglobal = [](rbx::State* R, const char* n) {
		rbx::getfield(R, rbx::GLOBALS, n);
	};

	auto getregistry = [](rbx::State* R, const char* n) {
		rbx::getfield(R, rbx::REGISTRY, n);
	};

	auto setglobal = [](rbx::State* R, const char* n) {
		rbx::setfield(R, rbx::GLOBALS, n);
	};

	auto setregistry = [](rbx::State* R, const char* n) {
		rbx::setfield(R, rbx::REGISTRY, n);
	};

	auto topointer = [](rbx::State* R, int idx) {
		return rbx::index2adr(R, idx)->value.p;
	};

	auto touserdata = [](rbx::State* R, int idx) {
		rbx::TValue* obj = rbx::index2adr(R, idx);
		void*& ptr = obj->value.p;

		if (obj->tt == rbx::TUSERDATA) {
			return reinterpret_cast<void*>(reinterpret_cast<uintptr_t>(ptr) + 0x10);
		}

		return ptr;
	};

	auto tolstring = [](rbx::State* R, int idx, std::size_t* out) {
		rbx::TValue* obj = rbx::index2adr(R, idx);

		if (out != nullptr) {
			const std::uintptr_t& svalue = rbx::svalue(obj);
			*out = (std::size_t)((svalue + 12) + *reinterpret_cast<std::uintptr_t*>(svalue + 12));
		}

		return rbx::rawstrvalue(obj);
	};

	auto tostring = [](rbx::State* R, int idx) {
		return rbx::tolstring(R, idx, nullptr);
	};

	auto tonumber = [](rbx::State* R, int idx) {
		double result;
		*reinterpret_cast<uint64_t*>(&result) = rbx::index2adr(R, idx)->value.n_xor ^ number_xor;
		return result;
	};

	auto tointeger = [](rbx::State* R, int idx) {
		return _tointeger(R, idx, nullptr);
	};

	auto tothread = [](rbx::State* R, int idx) {
		return rbx::thvalue(rbx::index2adr(R, idx));
	};

	auto isreadonly = [](rbx::State* R, int idx) {
		return rbx::hvalue(rbx::index2adr(R, idx))->readonly;
	};

	auto pushlightuserdata = [](rbx::State* R, void* ud) {
		rbx::setpvalue(R->top, ud);
		rbx::incr_top(R);
	};

	auto pushcclosure = [](rbx::State* R, rbx::CFunction f, int nups) {
		_pushcclosure(R, rbx::callcheck_address, "", nups, 0);
		const auto cl = reinterpret_cast<std::uintptr_t>(rbx::topointer(R, -1));
		*reinterpret_cast<std::uintptr_t*>(cl + 28) = reinterpret_cast<std::uintptr_t>(f);
	};

	auto pushnumber = [](rbx::State* R, double n) {
		rbx::setnvalue(R->top, n, number_xor);
		rbx::incr_top(R);
	};

	auto pushboolean = [](rbx::State* R, bool b) {
		rbx::setbvalue(R->top, b);
		rbx::incr_top(R);
	};

	auto pushlstring = [](rbx::State* R, const char* s, std::size_t l) {
		rbx::setsvalue(R->top, rbx::newlstr(R, s, l));
		rbx::incr_top(R);
	};

	auto pushnil = [](rbx::State* R) {
		rbx::setnilvalue(R->top);
		rbx::incr_top(R);
	};

	auto pushstring = [](rbx::State* R, const char* s) {
		if (s) {
			rbx::pushlstring(R, s, strlen(s));
		}
		else {
			rbx::pushnil(R);
		}
	};

	auto pushvalue = [](rbx::State* R, int idx) {
		rbx::setobj(R->top, index2adr(R, idx));
		rbx::incr_top(R);
	};

	auto pushobject = [](rbx::State* R, rbx::TValue* obj) {
		rbx::setobj(R->top, obj);
		rbx::incr_top(R);
	};

	auto ref = [](rbx::State* R, int idx) {
		if (idx == 0 || rbx::type(R, -1) == rbx::TNIL) {
			rbx::pop(R, 1);
			return static_cast<int>(rbx::REFNIL);
		}
		rbx::rawgeti(R, idx, rbx::FREELIST_REF);

		int ref = rbx::tointeger(R, -1);

		rbx::pop(R, 1);
		if (ref) {
			rbx::rawgeti(R, idx, ref);
			rbx::rawseti(R, idx, rbx::FREELIST_REF);
		}
		else {
			ref = rbx::objlen(R, idx) + 1;
		}
		rbx::rawseti(R, idx, ref);
		return ref;
	};

	auto sandbox = [](rbx::State* R, int identity) {
		std::array unk{ 0, 0 };
		_sandbox(R, identity, unk.data());
	};
}
