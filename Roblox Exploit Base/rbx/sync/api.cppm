module;

#include <string>

export module rbx.api;

import memory;

import rbx.object;
import rbx.constants;
import rbx.task_scheduler;
import rbx.bypass.retcheck;

auto get_lua_state_from_script_context = reinterpret_cast<rbx::State * (__thiscall*)(std::uintptr_t, int*)>(mem::rebase(0x7a7fb0, 0x400000));

auto _index2adr = reinterpret_cast<rbx::TValue * (__fastcall*)(rbx::State*, int)>(mem::rebase(0x15cbbf0, 0x400000));

auto number_xor = *reinterpret_cast<std::uint64_t*>(mem::rebase(0x2a84930, 0x400000));

export namespace rbx {
	auto get_task_scheduler = reinterpret_cast<rbx::task_scheduler * (*)()>(mem::rebase(0x10aeb60, 0x400000));

	std::uintptr_t get_script_context() {
		return ([]() -> std::uintptr_t {
			for (const auto& job : *rbx::get_task_scheduler()) {
				if (job->name == "WaitingScriptJob") {
					return (*reinterpret_cast<rbx::task_scheduler::waiting_script_job*>(job.get())).script_context;
				}
			}

			return 0;
		})();
	}

	auto get_lua_state = []() -> rbx::State* {
		int flag = 0;
		return get_lua_state_from_script_context(get_script_context(), &flag);
	};

	auto getfield = reinterpret_cast<void(*)(rbx::State*, int, const char*)>(rbx::bypass::retcheck(reinterpret_cast<std::uint8_t*>(mem::rebase(0x15cc140, 0x400000))));
	auto setfield = reinterpret_cast<void(*)(rbx::State*, int, const char*)>(rbx::bypass::retcheck(reinterpret_cast<std::uint8_t*>(mem::rebase(0x15cd7e0, 0x400000))));
	auto pcall = reinterpret_cast<int(*)(rbx::State*, int, int, int)>(rbx::bypass::retcheck(reinterpret_cast<std::uint8_t*>(mem::rebase(0x15cc8c0, 0x400000))));

	auto index2adr = [](rbx::State* R, int idx) {
		if (idx > 0) {
			return R->base + (idx - 1);
		}

		return _index2adr(R, idx);
	};

	auto type = [](rbx::State* R, int idx) {
		return index2adr(R, idx)->tt;
	};

	auto gettop = [](rbx::State* R) {
		return R->top - R->base;
	};

	auto settop = [](rbx::State* R, int idx) {
		if (idx >= 0) {
			while (R->top < R->base + idx) {
				setnilvalue(R->top++);
			}

			R->top = R->base + idx;
		}
		else {
			R->top += idx + 1;
		}
	};

	auto pop = [](rbx::State* R, int n) {
		settop(R, -1 - (n));
	};

	auto getglobal = [](rbx::State* R, const char* n) {
		getfield(R, rbx::GLOBALS, n);
	};

	auto setglobal = [](rbx::State* R, const char* n) {
		setfield(R, rbx::GLOBALS, n);
	};

	auto pushnumber = [](rbx::State* R, double n) {
		rbx::setnvalue(R->top, n, number_xor);
		rbx::incr_top(R);
	};
}
