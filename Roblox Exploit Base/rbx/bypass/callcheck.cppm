module;

#include <Windows.h>
#include <cstdint>
#include <iostream>

export module rbx.bypass.callcheck;

import memory;

import rbx.api;
import rbx.object;
import rbx.constants;

static int handler(rbx::State* R) {
    auto cl = reinterpret_cast<rbx::CClosure*>(rbx::topointer(R, -1 - rbx::gettop(R)));
    //return (*reinterpret_cast<rbx::CFunction*>(cl + 28))(R);
    return cl->extra_space(R);
    //return rbx::clvalue(rbx::index2adr(R, -1 - rbx::gettop(R)))->c.extra_space(R);
}

export namespace rbx::bypass {
	void callcheck() {
        if (callcheck_address == 0) {
		    callcheck_address = mem::find_pattern("\xCC\xCC\xCC\xCC", "xxxx");

            AddVectoredExceptionHandler(1, [](PEXCEPTION_POINTERS ex) -> LONG WINAPI {
                if (ex->ExceptionRecord->ExceptionCode == EXCEPTION_BREAKPOINT) {
                    if (ex->ContextRecord->Eip == callcheck_address) {
                        ex->ContextRecord->Eip = reinterpret_cast<DWORD>(handler);
                        return EXCEPTION_CONTINUE_EXECUTION;
                    }
                }

                return EXCEPTION_CONTINUE_SEARCH;
            });
        }
	}
}
