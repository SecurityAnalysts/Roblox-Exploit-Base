#include <iostream>
#include <thread>
#include <functional>
#include <Windows.h>

import rbx.api;
import rbx.init;
import rbx.object;
import rbx.task_scheduler;
import rbx.bypass.console;
import rbx.bypass.callcheck;
import rbx.constants;

int main() {
	//rbx::bypass::console(L"Base");

	auto scheduler = rbx::get_task_scheduler();
	scheduler->hook_job();
	scheduler->push([]() {
		rbx::State* roblox_state = rbx::get_lua_state();
		rbx::State* main_state = rbx::newthread(roblox_state);
		
		rbx::sandbox(main_state, 7);
		rbx::init(main_state);
		rbx::bypass::callcheck();

		rbx::pushcclosure(main_state, [](rbx::State* R) {
			if (rbx::type(R, 1) == rbx::TTHREAD) {
				const auto& thread = rbx::tothread(R, 1);
			
				rbx::pushvalue(thread, rbx::GLOBALS);
				rbx::pushobject(R, rbx::index2adr(thread, -1));
			}
			else {
				rbx::pushnil(R);
			}

			return 1;
		}, 0);
		rbx::setregistry(main_state, "gettenv");

		rbx::getglobal(main_state, "game");
		rbx::getfield(main_state, -1, "Players");
		rbx::getfield(main_state, -1, "LocalPlayer");
		rbx::getfield(main_state, -1, "Character");
		rbx::getfield(main_state, -1, "Humanoid");
		rbx::pushnumber(main_state, 50);
		rbx::setfield(main_state, -2, "WalkSpeed");
	});

	return 0;
}

bool __stdcall DllMain(void* instance_handle, std::uintptr_t reason, void*) {
	switch (reason) {
	case DLL_PROCESS_ATTACH:
		std::thread(main).detach();
		break;
	case DLL_PROCESS_DETACH:
		break;
	}

	return true;
}
